# 비트 연산
- 1. 이진수로 변환
- 2. 각 자리를 AND, OR 연산한다.
```python
0x4A3 | 25
# 2의 제곱 중 25와 가장 가까운 제곱을 빼고 그 다음 제곱을 빼고 한다.
# 25 = 16 + 8 + 1
print(0x4A3 | 25) # 0b10010111011
```
- XOR 은 동일한 수로 XOR을 2번하게 되면 다시 원래 수가 나온다.
```python
7040 ^ 1004 # 6252
6252 ^ 1004 # 7040
```
- Left Shift <<: 특정 수 만큼 비트를 왼쪽으로 밀어낸다.
- Right Shift >>: 특정 수 만큼 비트를 오른쪽으로 밀어낸다.(우측 비트들이 제거된다.)
```python
print(bin(0b1101 << 2)) # 0b110100
print(bin(0b1101 >> 2)) # 0b11

#shift 연산자
print(1 << 1, bin(1 << 1)) # 2 10
print(1 << 2, bin(1 << 2)) # 4 100
print(1 << 3, bin(1 << 3)) # 8 1000
print(1 << 4, bin(1 << 4))  # 16 10000

print(7 >> 1) 3
```

## 비트연산 응용1
- 1 << n
  - 2ⁿ의 값을 갖는다.
  - 임베디드 분야에서 계산을 빠르게 하기 위해 사용된다.

## 비트연산 응용2
- i & (1<<n)
  - i의 n 번째 비트가 1인지 아닌지를 확인할 수 있다.
    - ex) 1101 & (1 << 2)
    - 1101 에서 2번 bit가 1인지 확인 가능하다.(결괏값 = 0100)
    - 결과값이 0보다 크면 n번째 비트는 1임이 확정된다.
    - ```python
      arr = [1, 2, 3, 4] # 16개
      for i in range(1 << len(arr)):
        for idx in range(len(arr)):
          # (1 << idx) : 0b1, 0b10, 0b100, 0b1000
          # i 의 idx 번째 bit가 1인지 확인(부분 집합에 포함 되어 있는지 확인)
          if i & (1 << idx):
            print(arr[idx], end=" ")
          print()

      # 응용. 합이 10인 부분 집합만 출력해라
      arr = [1, 2, 3, 4, 5, 6]
      for i in range(1 << len(arr)):
        subset = []
        total = 0
        for idx in range(len(arr)):
          if i & (1 << idx):
            subset.append(arr[idx])
            total += arr[idx]
        if total == 10:
          print(f'부분집합: {subset})
      ```
### 음수 표현 방법
- 컴퓨터는 음수를 "2의 보수"로 관리한다.
- 맨 앞자리 bit(MSB)는 음수 or 양수
  - 1. 부호 비트만 사용
    - 숫자 표현엔 문제가 x
    - 연산자 사용 시에 문제가 발생
  - 2. 1의 보수
    - 각 비트를 뒤집어서 표현하자.
    - 문제점: 0을 표현하는 방법이 2개가 생김.
  - 3. 2의 보수
    - 각 비트를 뒤집고, 1을 더하자.
      - 덧셈 연산 시 over bit는 삭제

#### 신기한 2의 보수
- 2의 보수를 취한 수를, 한번 더 2의 보수를 취하면 **원래의 값으로 돌아온다.**
- 10001의 2의 보수
  - 수를 뒤집고 + 1을 한다.
  - 01110 + 1 = 01111
- 01110 의 2의 보수
  - 10000 + 1 = 10001

####  Bitwise NOT 연산자를 파이썬에서 수행하기
- 파이썬에서는 ~4를 수행하면 -5가 출력된다.
  - **파이썬이 ~5를 -5로 출력하는 과정**
  - 4는 0b**0**100이다. (MSB: 양수이므로 0)
  -  NOT 연산자로 인해 뒤집으면 1011이 된다.
  -  MSB는 1이 되었고 (음수), 나머지 bit는 011이다.
  -  나머지 bit에 대해 2의 보수를 취하면 100 + 1 = 101 이므로 5가 된다.
-  따라서 -5가 된다.


# 실수
- 파이썬에서 실수 출력 방법
- 파이썬은 f-string을 문법을 지향한다.
- **소수점 출력 방법**
- {t2: .2f} : t2의  값을 소수점 둘째 자리에서 반올림하여 표현
- **컴퓨터는 실수를 내부적으로 근사적으로 관리한다.**
  - 실수는 정확한 값이 아니라 근사 값으로 저장되는데 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다.


#### 파이썬에서의 실수 표현 범위를 알아보자
- 파이썬에서는 다른 언어와 달리 내부적으로 더 큰 규모의 자료구조를 사용해서 훨씬 넓은 범위의 실수를 표현할 수 있다.
- 최대로 표현할 수 있는 값은 약 1.8 X 10³⁰⁸이고 이 이상은 inf로 표현(참고로 1억은 1x10⁸)
- 최소로 표현할 수 있는 값은 약 0.5 x 10⁻³²⁴이며, 이 이하는 0으로 표현

#### 소수점이 있는 10진수를 2진수로 변환하기
- 정수의 경우, 2로 나눈 나머지들을 역순으로 출력한 값
- 소수점은 반대로 2를 곱하고 그 몫들을 출력한 값

# 실수의 표현
- 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법을 사용한다.
- 이 표기 법은 IEEE 754이라는 컴퓨터에서 부동소수점을 표기하는 국제 표준이다.
- **부동** 소수점 표기 방법은 소수점의 위치를 고정싴켜 표현하는 방식이다.
- 소수점의 위치를 왼쪽의 가장 유효한 숫다 다음으로 고정시키고 밑수의 지수승으로 표현
- 실수를 저장하기 위한 형식(IEEE 754, 32bit - single precision 표기법 기준)
  - 32bit 구조
  - 부호 1비트 : 0이면 양수, 1이면 음수
  - 지수부(exponent): 부동소수점의 크기 + bias 값(음수를 저장하기 위해 127 정도를 더해서 관리)
  - 가수부(mantissa): 실질적 수

#### 컴퓨터는 실수를 근사적으로 표현한다.
- 이진법으로 표현 할 수 없는 형태의 실수는 정확한 값이 아니라 근사 값으로 저장되는데 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다.
#### 실수 자료형의 유효 자릿수를 알아두자.
- 32 비트 실수형 유효자릿수(십진수) -> 약 6자리 (c++)
- 64비트 실수형 유효자릿수(십진수) -> 약 15자리(c++, java)
- 파이썬에서는 내부저긍로 더 많은 비트를 사용해서 훨씬 넓은 범위의 실수를 표현할 수 있다.



> [!NOTE]
> 1. 비트연산
>   - 연산자( &, |, ^, ~, <<, >> )
>   - 부분 집합 문제 등의 활용 방안
>     - [추천] 다양한 활용 방법 GPT 검색
> 2. 실수
>   - 컴퓨터의 실수 저장 및 활용 방법
>   - [주의사항] 근사치로 인한 오차
>     - 반올림, 버림 등 문제를 잘 읽자.