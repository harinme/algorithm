- **대표적인 문제 해결 기법 비교**
    1. **완전 탐색(Brute Force)**
        - 모든 경우를 나열 & 테스트
        - 구현 난이도가 낮고 확실한 정답 도출
        - 경우의 수가 큰 문제에는 **시간 초과** 위험
    2. **탐욕(Greedy)**
        - 매 순간 **최적**이라고 생각되는 해를 선택
        - 전역적 최적해를 보장하지 못할 수 있음
    3. **분할 정복(Divide and Conquer)**
        - 문제를 더 작은 **하위 문제**로 나누어 해결한 뒤, 결합
        - 예: 병합 정렬, 퀵 정렬
    4. **동적 프로그래밍(DP)**
        - 이전에 계산한 결과(부분 문제)를 **메모**하여 중복 계산 방지
        - 최적화 문제에 자주 사용
    
    > 실제 문제 풀이 시, **완전 탐색으로 정답을 우선 구하고**, 성능 개선(탐욕, DP 등)으로 최적화하는 경우가 많다.
    > 

## **분할 정복(Divide and Conquer)**

분할 정복은 **복잡한 문제**를 더 작은 문제로 분할(Divide)하고, 각 부분 문제를 정복(Conquer)하여 해결한 뒤, 그 결과를 합쳐서(Merge) 최종 해답에 이르는 **알고리즘 설계 기법**이다. 대표적인 예시로 **병합 정렬(Merge Sort)**, **퀵 정렬(Quick Sort)**, **이진 탐색(Binary Search)** 등이 있다.

---

## **1. 기본 개념**

1. **Divide (분할)**
    - 큰 문제를 여러 부분으로 나눈다. (보통 절반 혹은 균등하게)
    - 예) 리스트를 절반으로 나누어 각각 처리할 수 있게 함
2. **Conquer (정복)**
    - 분할된 부분 문제를 **재귀적으로 해결** (더 이상 나눌 수 없거나 기저 사례에 도달할 때까지)
    - 예) 절반씩 나눠진 리스트를 각각 정렬·탐색 등 처리
3. **Combine (병합/통합)**
    - 각 부분 문제의 해답을 합쳐서(or 비교해서) **최종 해답**을 만든다.
    - 예) 정렬된 작은 리스트들을 다시 합쳐 전체를 정렬

### **1.1 흐름 예시 (병합 정렬을 예로 들면)**

1. **Divide**: 배열을 반으로 분할 (size가 1이 될 때까지)
2. **Conquer**: size=1이면 이미 정렬된 상태이므로 그대로 (재귀 기저 사례)
3. **Combine**: 정렬된 두 배열을 하나로 병합(Merge)

---

## **2. 대표 예시: 병합 정렬(Merge Sort)**

병합 정렬은 “분할 정복” 기법을 가장 직관적으로 보여주는 알고리즘 중 하나이다.

1. **분할**: 배열을 절반으로 나눈다.
2. **재귀 정렬**: 왼쪽 부분 배열과 오른쪽 부분 배열 각각 **병합 정렬**
3. **병합**: 두 부분 배열이 정렬된 상태이므로, 이를 **합치면서 전체를 정렬**

### **2.1 시간 복잡도**

- 각 단계에서 O(N)로 병합하고, 단계 수가 **log₂(N)**
- 결과적으로 **O(N log N)**

---

## **3. 분할 정복 알고리즘의 공통 구조**

- **이진 탐색(Binary Search)**
    - 분할: 배열을 반으로 나눈 뒤, 탐색해야 하는 구간을 결정
    - 기저 사례: 찾는 값이 배열 중간 원소와 같거나, 구간 크기가 0이 될 때
- **퀵 정렬(Quick Sort)**
    - 분할: 피벗 기준 왼/오른쪽 부분 배열로 분할
    - 기저 사례: 배열 크기가 1 이하
- **병합 정렬(Merge Sort)**
    - 분할: 배열 절반씩 분할
        - 병합: 정렬된 부분 배열들을 합침
    - 기저 사례: 배열 길이 1 이하

### **3.1 장점과 단점**

- **장점**:
    - 큰 문제를 **논리적으로 작은 문제**로 나누어 해결 가능
    - 재귀로 표현 시 코드가 간결해짐
- **단점**:
    - 재귀 호출에 따른 **스택 사용**, 큰 문제에서 깊은 호출 발생 가능
    - 문제에 따라 부분 문제 해결 후 **병합 과정** 구현이 추가 필요(메모리 사용 등)

---

## **4. 요약**

1. **분할 정복(Divide and Conquer)**: 복잡한 문제를 작게 나누어(분할) 해결(정복)하고, 결과를 결합하여 최종 해답을 얻는 방법론
2. **병합 정렬**(Merge Sort)은 이를 대표적으로 시각화할 수 있는 정렬 알고리즘 → O(N log N)
3. **다른 예**: 퀵 정렬, 이진 탐색, 기타 트리/그래프 문제 등에서도 분할 정복이 널리 사용됨
4. **학습 포인트**
    - 재귀 함수를 통해 **기저 사례**와 **분할 후 병합** 과정을 설계
    - 각 단계에서 문제 크기가 **절반 이하**로 줄어들어 **log N** 레벨이 형성

**결론**

분할 정복은 **강력한 알고리즘 설계 기법**으로, **병합 정렬**은 그 대표적인 사례. 
`“문제를 작은 크기로 잘게 나누고, 각각 푼 뒤 합친다”`라는 사고방식으로 이해하면 훨씬 쉽다.