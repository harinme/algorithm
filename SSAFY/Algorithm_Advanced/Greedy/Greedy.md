# **탐욕 알고리즘(Greedy Algorithm)**

알고리즘 문제 해결 기법 중 하나로, **“현재 시점에서 가장 좋아 보이는 선택을 즉시 해나가면서”** 전체 문제의 해답에 도달하려고 하는 방식이다. 

완전 탐색(Brute-Force)보다 빠르게 해답을 구할 수 있지만, **항상 최적해를 보장**하지는 않는다.

- **대표적인 문제 해결 기법 비교**
    1. **완전 탐색(Brute Force)**
        - 모든 경우를 나열 & 테스트
        - 구현 난이도가 낮고 확실한 정답 도출
        - 경우의 수가 큰 문제에는 **시간 초과** 위험
    2. **탐욕(Greedy)**
        - 매 순간 **최적**이라고 생각되는 해를 선택
        - 전역적 최적해를 보장하지 못할 수 있음
    3. **분할 정복(Divide and Conquer)**
        - 문제를 더 작은 **하위 문제**로 나누어 해결한 뒤, 결합
        - 예: 병합 정렬, 퀵 정렬
    4. **동적 프로그래밍(DP)**
        - 이전에 계산한 결과(부분 문제)를 **메모**하여 중복 계산 방지
        - 최적화 문제에 자주 사용
    
    > 실제 문제 풀이 시, **완전 탐색으로 정답을 우선 구하고**, 성능 개선(탐욕, DP 등)으로 최적화하는 경우가 많다.
    > 

---

# **1. 개념 및 특징**

1. **탐욕적 선택(Greedy Choice)**
    - 매 단계에서 "**이 순간 최적으로 보이는 해**"를 선택
    - 한 번 선택한 결과(의사결정)를 **다시 바꾸지 않고** 계속 진행
2. **최적 부분 구조(Optimal Substructure)**
    - 문제를 여러 부분 문제로 쪼갰을 때, **해결 과정을 이어붙이면 최적해로 이어지는지**가 중요
    - 탐욕적 접근이 각 단계에서도 **안전하게** 최적을 보장한다면, 전체도 최적
3. **장점**
    - 구현이 비교적 **단순**
    - 빠르게(선형 혹은 준선형 시간) 해답을 구할 수 있음
4. **단점**
    - 매 순간 "그럴듯한" 선택을 하지만, 전체적으로는 **최적해가 아닐 수 있음**
    - 특정 조건(예: 코인이 배수 관계일 때 등)에서만 **정말 최적**을 보장

---

# **2. 예시: 거스름돈(동전 교환)**

### **2.1 문제 시나리오**

- 손님이 낸 돈에서 물건 값이 빠진 **거스름돈**을 **최소 동전 수**로 거슬러주기
- 예) 물건값 1200원, 받은 돈 2000원 → 거스름돈 800원
- **동전 종류**가 500원, 100원, 50원, 10원이라고 가정 → 800원을 500 + 100 + 100 + 100 = **동전 4개**
    - 더 구체적으로, 500원 1개 + 100원 3개 = 800원

### **2.2 탐욕(Greedy) 전략**

1. **가장 가치가 큰(금액이 큰) 동전부터** 최대한 많이 사용
2. 남은 거스름돈을 그 다음으로 큰 동전으로 거슬러줌
3. 더 이상 거스름돈이 0원이 될 때까지 반복

> 이 방법은 동전이 10·50·100·500처럼 특정 배수 관계일 때, 항상 최적임(동전 수 최소)
> 

### **2.3 코드 예시**

```python
def get_minimum_coins(coin_list, amount):
    """
    coin_list: 동전 금액 리스트 (예: [500, 100, 50, 10])
    amount: 거슬러줄 총 금액 (예: 800)
    return: {동전금액: 개수} 형태의 딕셔너리
    """
    result = {}
    # 큰 동전부터 사용
    coin_list.sort(reverse=True)

    for coin in coin_list:
        if amount >= coin:
            coin_count = amount // coin  # 현재 동전 몇 개 쓸 수 있는지
            amount -= coin_count * coin
            result[coin] = coin_count

    return result

# 사용 예시
coins = [10, 50, 100, 500]
change_amount = 800
change_result = get_minimum_coins(coins, change_amount)

print("거스름돈:", change_amount)

for c, cnt in change_result.items():
    print(f"{c}원 동전: {cnt}개")

```

```
거스름돈: 800
500원 동전: 1개
100원 동전: 3개
```

**해설**

1. `coin_list.sort(reverse=True)` → 큰 동전부터 차례대로 시도
2. `coin_count = amount // coin` → 현재 남은 금액에서 해당 동전을 최대 몇 개 사용할 수 있는지
3. 거슬러준 후 남은 금액(`amount`)을 감소
4. 결과: 딕셔너리 형태 → {500:1, 100:3} 등

### **2.4 탐욕 알고리즘이 실패하는 경우**

- 동전이 `[500, 400, 100, 50, 10]` 같은 구조라면, 거스름돈 800원을
    - Greedy: 500 한 번, 400 한 번(불가능?),... 하면서 실수할 수도 있음
    - 사실 400원×2 → 2개 동전이 끝
- 실제론 "동전간 배수 관계"가 깨지면, 그리디가 **최적해**를 못 구할 수 있음

---

# **3. 예시: 배낭(Knapsack) 문제**

### **3.1 문제 개요**

- 도둑이 배낭 용량 W를 초과하지 않으면서 **가치**가 최대가 되도록 물건을 담으려 함
- 각 물건은 (무게, 가치) 형태로 제공
- **0-1 Knapsack**: 물건을 통째로만(쪼갤 수 없음) 담는다
- **Fractional Knapsack**: 물건을 **분할**하여 일부만 담을 수 있음

### **3.2 탐욕적 접근 vs. 최적해**

1. **0-1 Knapsack**
    - **탐욕 전략 예시**:
        1. 가치가 높은 순
        2. 무게가 가벼운 순
        3. 가치/무게가 가장 큰 순 등
    - 어떤 전략도 항상 최적해를 보장하지 않음 (반례 존재)
    - 보통 동적 프로그래밍(DP)으로 푸는 경우가 많음
2. **Fractional Knapsack**(물건을 쪼갤 수 있는 경우)
    - “**무게당 가치**가 높은 물건부터 담는다”는 탐욕 전략이 **항상 최적**
    - 예: 무게 30 한도로, (무게당 가치) 높은 거 먼저 채우면 최적

---

# **4. 탐욕 알고리즘의 핵심 요약**

1. **탐욕적 선택 속성(Greedy Choice Property)**
    - 그 순간의 선택이 최적해로 가는 데 **위험**이 없음을 보장(또는 증명)해야, 전체로도 최적
2. **최적 부분 구조(Optimal Substructure)**
    - 전체 문제를 해결하려 할 때, 부분 문제를 적절히 해결하면 확장 가능해야 함
3. **장점**:
    - **간단하고 빠름**(주로 `$O(N log N)$` or `$O(N)$`)
    - **편리**: 문제에 대해 "가장 좋아 보이는 한 가지 규칙"을 적용
4. **단점**:
    - 전역 최적을 보장하지 못하는 경우가 많음
    - 제한된 조건에서만 올바른 최적해를 보장 (코인 배수 관계, Fractional Knapsack 등)

---

# **5. 주의사항**

- **탐욕 알고리즘**은 “**단계적**으로 최적 같아 보이는 선택”을 하지만, 결과가 **글로벌 최적**이 아닐 수도 있음
- 증명(Proof)이 중요한 이유: “이 문제에서 탐욕이 최적임을 보장하는 근거”가 있어야 함
- 일반적으로,
    - **코인 거스름돈**: 동전이 특정 규칙(배수)일 때 탐욕이 최적
    - **Fractional Knapsack**: 무게당 가치 순으로 담으면 최적
    - **0-1 Knapsack**: 탐욕이 항상 최적 아님 → DP or 백트래킹 필요

---

# **6. 대표적인 Greedy 알고리즘 예시들**

| 알고리즘 | 문제 유형 | 설명 |
| --- | --- | --- |
| **동전 교환** | 단일 예시 | 큰 동전부터 사용 (단, 동전 구조가 배수 형태여야 최적 보장) |
| **Fractional Knapsack** | 배낭 문제(분할 가능) | 물건을 쪼개어 담을 수 있을 때, 무게 대비 가치가 높은 순으로 담기 |
| **Prim** | 그래프(MST 찾기) | 서브트리를 확장하며 **최소 스패닝 트리** 구성 |
| **Kruskal** | 그래프(MST 찾기) | 간선을 오름차순으로 선택, 싸이클이 안 생기면 채택 |
| **Dijkstra** | 그래프(최단 경로) | 시작 노드에서 가장 가까운 노드를 우선 방문, 점차 거리 확정 |

---

# **7. 정리**

- **탐욕 알고리즘(Greedy)**: 매 순간 최적처럼 보이는 해를 선택하는 기법
- **장점**: 빠르고 구현이 간단
- **단점**: 항상 최적해를 주는 것은 아니다
- 특정 문제(코인 거스름돈, Fractional Knapsack, 최소 스패닝 트리 등)에서는 **탐욕적 접근**이 **확실히 최적**임이 증명되어 널리 쓰임
- 다른 문제에서는 **탐욕이 실패할 수 있음** → 동적 프로그래밍, 백트래킹, 분할 정복 등 다른 기법 고려

**“어떤 문제는 탐욕으로 쉽게 끝나지만**, 
어떤 문제는 탐욕으로는 안 된다”는 판단을 할 수 있게 되며, 이는 문제 조건(배수 관계, 분할 가능 등)에 따라 달라진다.